{"version":3,"file":"bundled.js","mappings":"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","sources":["webpack://minimal_webpack_template/webpack/bootstrap","webpack://minimal_webpack_template/webpack/runtime/define property getters","webpack://minimal_webpack_template/webpack/runtime/hasOwnProperty shorthand","webpack://minimal_webpack_template/./src/astar.ts","webpack://minimal_webpack_template/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { Vector2, CellType } from \"./index\";\n// 1:1 correspondence: N (number) <-> coor (Vector2) <-> cell (Cell)\nexport function astar(grid, diagonalFlag) {\n    const [[startCoor, targetCoor], isPathFound] = updateGrid(grid, diagonalFlag);\n    let pathCoor = targetCoor;\n    while (pathCoor) {\n        console.log(pathCoor);\n        if (!pathCoor.isEqual(startCoor) && !pathCoor.isEqual(targetCoor)) {\n            grid.set(pathCoor, CellType.Path);\n        }\n        pathCoor = grid.get(pathCoor).parent;\n    }\n    return isPathFound;\n}\n// Update the grid cell 'parent' and 'distance' properties.\nfunction updateGrid(grid, diagonalFlag) {\n    // Reset astar distance and parent to default.\n    for (let i = 0; i < grid.rows; i++) {\n        for (let j = 0; j < grid.cols; j++) {\n            grid.data[i][j].distance = Infinity;\n            grid.data[i][j].parent = null;\n        }\n    }\n    const endpoints = grid.typeCoorArray(CellType.Endpoint);\n    const startCoor = endpoints[0];\n    const targetCoor = endpoints[1];\n    grid.get(startCoor).distance = 0; // Distance is how far from start.\n    let current = grid.coorToN(startCoor);\n    const target = grid.coorToN(targetCoor);\n    const unvisited = new Set([current]);\n    const visited = new Set();\n    while (current != target) {\n        const currentCoor = grid.NToCoor(current);\n        // Get unvisited neighbours.\n        const nextCoors = getNextCoors(currentCoor, visited, grid, diagonalFlag);\n        // Update unvisited neighbours.\n        const distanceNextPotential = grid.get(currentCoor).distance + 1;\n        nextCoors.forEach(nextCoor => {\n            const nextCell = grid.get(nextCoor);\n            unvisited.add(grid.coorToN(nextCoor));\n            if (distanceNextPotential < nextCell.distance) {\n                nextCell.distance = distanceNextPotential;\n                nextCell.parent = currentCoor;\n            }\n        });\n        // Update unvisited and visited. Update current.\n        unvisited.delete(current);\n        visited.add(current);\n        const bestUnvisitedCoor = getBestUnvisitedCoor(grid, Array.from(unvisited).map(N => grid.NToCoor(N)), targetCoor, diagonalFlag);\n        if (bestUnvisitedCoor) {\n            current = grid.coorToN(bestUnvisitedCoor);\n        }\n        else { // Unable to find path.\n            return [endpoints, false];\n        }\n    }\n    // Return target coordinates, going to need it to jump via parent to start.\n    return [endpoints, true];\n}\n// E.g: getNextCoors(new Vector2(0, 0), new Set([1]), grid, true) \nfunction getNextCoors(currentCoor, visited, grid, diagonalFlag) {\n    const neighbourCoors = getNeighbourCoors(currentCoor, grid.typeMask(CellType.Obstacle), diagonalFlag);\n    return neighbourCoors.filter(neighbourCoor => !visited.has(grid.coorToN(neighbourCoor)));\n}\n// E.g: getNeighbours(new Vector2(1, 1), grid.getCellMask(CellType.Obstacle), true)\nfunction getNeighbourCoors(cellCoor, mask, diagonalFlag) {\n    const neighbours = Array();\n    const predBase = (coor) => coor.isValidCellCoor() && !mask[coor.y][coor.x];\n    // -- Cardinals:\n    // Which cardinal cells are available, rotating clockwise starting from right direction. \n    // Used to determine if diagonal cells are reachable.\n    const cardinalBools = Array(4);\n    cardinalBools.fill(false);\n    for (let i = 0; i < 4; i++) {\n        const angle = i * Math.PI / 2;\n        const diffVect = new Vector2(Math.cos(angle), Math.sin(angle)).map(component => Math.round(component));\n        const cardinal = cellCoor.plus(diffVect);\n        if (predBase(cardinal)) {\n            neighbours.push(cardinal);\n            cardinalBools[i] = true;\n        }\n    }\n    // -- Diagonals:\n    if (diagonalFlag) {\n        const circInc = (val, bound) => (val + 1 == bound) ? 0 : val + 1;\n        for (let i = 0; i < 4; i++) {\n            const angle = i * Math.PI / 2 + Math.PI / 4;\n            const diffVect = new Vector2(Math.cos(angle), Math.sin(angle)).map(component => Math.round(component));\n            const diagonal = cellCoor.plus(diffVect);\n            const diagonalIsReachable = cardinalBools[i] || cardinalBools[circInc(i, 4)];\n            if (predBase(diagonal) && diagonalIsReachable) {\n                neighbours.push(diagonal);\n            }\n        }\n    }\n    return neighbours;\n}\n// E.g: getBestUnvisitedCoor([new Vector2(0, 1), new Vector2(1, 0)], new Vector2(2, 0))\nfunction getBestUnvisitedCoor(grid, unvisitedCoors, targetCoor, diagonalFlag) {\n    let bestUnvisitedCoor = null;\n    let minScore = Infinity;\n    unvisitedCoors.forEach(unvisitedCoor => {\n        const unvisitedCell = grid.get(unvisitedCoor);\n        const score = coorDist(unvisitedCoor, targetCoor, diagonalFlag) + unvisitedCell.distance;\n        if (score < minScore) {\n            minScore = score;\n            bestUnvisitedCoor = unvisitedCoor;\n        }\n    });\n    return bestUnvisitedCoor;\n}\nfunction coorDist(A, B, diagonalFlag) {\n    const dx = Math.abs(A.x - B.x);\n    const dy = Math.abs(A.y - B.y);\n    const cardinalDistance = dx + dy;\n    return diagonalFlag ? cardinalDistance - Math.min(dx, dy) : cardinalDistance;\n}\n","import { astar } from './astar';\nconst canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\nconst belowCanvas = document.getElementById('belowCanvas');\nconst toggleButton = document.getElementById('toggleButton');\nconst toggleInfo = document.getElementById('toggleInfo');\nconst clearButton = document.getElementById('clearButton'); // Clear path, endpoints, and obstacles.\nconst diagonalCheckbox = document.getElementById('diagonalCheckbox');\nconst pathInfo = document.getElementById('pathInfo');\nconst COLS = 30;\nconst ROWS = 20;\nconst layout = {\n    padding: {\n        window: 10,\n        canvas: 10\n    },\n    cellSize: 30\n};\nexport var CellType;\n(function (CellType) {\n    CellType[CellType[\"Nothing\"] = 0] = \"Nothing\";\n    CellType[CellType[\"Obstacle\"] = 1] = \"Obstacle\";\n    CellType[CellType[\"Endpoint\"] = 2] = \"Endpoint\";\n    CellType[CellType[\"Path\"] = 3] = \"Path\";\n})(CellType || (CellType = {}));\nexport class Vector2 {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    plus(other) {\n        return new Vector2(this.x + other.x, this.y + other.y);\n    }\n    map(f) {\n        return new Vector2(f(this.x), f(this.y));\n    }\n    isValidCellCoor() {\n        return this.x >= 0 && this.x < COLS && this.y >= 0 && this.y < ROWS;\n    }\n    isEqual(other) {\n        return this.x == other.x && this.y == other.y;\n    }\n}\nclass Cell {\n    constructor(type, distance, parent) {\n        this.type = type;\n        // Used by astar\n        this.distance = distance;\n        this.parent = parent;\n    }\n}\nexport class Grid {\n    constructor(cols, rows) {\n        this.cols = cols;\n        this.rows = rows;\n        this.data = Array(this.rows); // 2D character array.\n        for (let i = 0; i < this.rows; i++) {\n            this.data[i] = Array(this.cols);\n            for (let j = 0; j < this.cols; j++) {\n                this.data[i][j] = new Cell(CellType.Nothing, Infinity, null);\n            }\n        }\n        // Graphics init\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, 1000, 1000);\n        ctx.beginPath();\n        // Vertical lines.\n        for (let x = layout.padding.canvas; x <= this.cols * layout.cellSize + layout.padding.canvas; x += layout.cellSize) {\n            ctx.moveTo(x, layout.padding.canvas);\n            ctx.lineTo(x, rows * layout.cellSize + layout.padding.canvas);\n        }\n        // Horizontal lines.\n        for (let y = layout.padding.canvas; y <= rows * layout.cellSize + layout.padding.canvas; y += layout.cellSize) {\n            ctx.moveTo(layout.padding.canvas, y);\n            ctx.lineTo(this.cols * layout.cellSize + layout.padding.canvas, y);\n        }\n        ctx.stroke();\n    }\n    get(cellCoor) {\n        return this.data[cellCoor.y][cellCoor.x];\n    }\n    set(cellCoor, type) {\n        this.get(cellCoor).type = type;\n        const left = cellCoor.x * layout.cellSize + layout.padding.canvas + 1;\n        const top = cellCoor.y * layout.cellSize + layout.padding.canvas + 1;\n        const edgeLen = layout.cellSize - 2;\n        ctx.fillStyle = cellColors.get(type);\n        ctx.fillRect(left, top, edgeLen, edgeLen);\n    }\n    coorToN(coor) {\n        return coor.y * this.cols + coor.x;\n    }\n    NToCoor(N) {\n        const y = Math.floor(N / this.cols);\n        const x = N - y * this.cols;\n        return new Vector2(x, y);\n    }\n    // Translate mousePos Vector2 into cell Vector2.\n    mousePosToCellCoor(mousePos) {\n        return mousePos.map((mouse) => Math.floor((mouse - layout.padding.canvas - layout.padding.window) / layout.cellSize));\n    }\n    // Count number of cells of a certain type on grid.\n    countCell(type) {\n        return this.data.flat().filter(cell => cell.type == type).length;\n    }\n    clickCell(cellCoor) {\n        const typeClicked = this.get(cellCoor).type;\n        if (typeClicked == CellType.Nothing) { // Toggle empty cell.\n            const endpointCount = this.countCell(CellType.Endpoint);\n            if (endpointCount < 2 || userAction.cellType == CellType.Obstacle) { // Can paint.\n                this.set(cellCoor, userAction.cellType);\n                if (userAction.cellType == CellType.Endpoint && endpointCount == 1) { // There are actually two endpoints now.\n                    this.drawPath();\n                }\n            }\n        }\n        else { // Toggle filled cell, it could be path (do nothing), endpoint, or obstacle.\n            if (typeClicked == CellType.Endpoint) {\n                this.clearPath();\n                const endpoints = this.typeCoorArray(CellType.Endpoint);\n                endpoints.forEach(e => this.set(e, CellType.Nothing));\n            }\n            else if (typeClicked == CellType.Obstacle) {\n                this.set(cellCoor, CellType.Nothing);\n                if (this.countCell(CellType.Endpoint) == 2) {\n                    this.clearPath();\n                    this.drawPath();\n                }\n            }\n        }\n    }\n    drawPath() {\n        console.log('drawing path');\n        if (astar(this, diagonalCheckbox.checked)) {\n            pathInfo.textContent = '';\n        }\n        else {\n            pathInfo.textContent = 'No path';\n        }\n    }\n    clearPath() {\n        console.log('clearing path');\n        this.typeCoorArray(CellType.Path).forEach(cell => this.set(cell, CellType.Nothing));\n    }\n    typeCoorArray(type) {\n        const ar = Array(); // Cell contents.\n        for (let x = 0; x < this.cols; x++) {\n            for (let y = 0; y < this.rows; y++) {\n                if (this.data[y][x].type == type) {\n                    ar.push(new Vector2(x, y));\n                }\n            }\n        }\n        return ar;\n    }\n    typeMask(type) {\n        const mask = Array(this.rows);\n        for (let y = 0; y < this.rows; y++) {\n            mask[y] = Array(this.cols);\n            for (let x = 0; x < this.cols; x++) {\n                if (this.data[y][x].type == type) {\n                    mask[y][x] = true;\n                }\n                else {\n                    mask[y][x] = false;\n                }\n            }\n        }\n        return mask;\n    }\n}\nconst cellColors = new Map();\ncellColors.set(CellType.Nothing, 'white');\ncellColors.set(CellType.Obstacle, 'black');\ncellColors.set(CellType.Endpoint, 'red');\ncellColors.set(CellType.Path, 'yellow');\nconst userAction = {\n    cellType: CellType.Obstacle,\n    lastCell: new Vector2(-1, -1),\n    isMousePressed: false // Variable updated by mousedown and mouseup event listeners.\n};\nlet grid = new Grid(COLS, ROWS);\ncanvas.style.top = `${layout.padding.window}px`;\ncanvas.style.left = `${layout.padding.window}px`;\nbelowCanvas.style.top = `${layout.padding.window + grid.rows * layout.cellSize + 20}px`; // 20px looks good.\nbelowCanvas.style.left = `${layout.padding.window + layout.padding.canvas}px`;\n// Called when mouse is clicked or dragged.\nfunction cellClickHandler(event, checkDifferent) {\n    const mousePos = new Vector2(event.x, event.y);\n    const cellCoor = grid.mousePosToCellCoor(mousePos);\n    if (cellCoor.isValidCellCoor() && (!checkDifferent || !cellCoor.isEqual(userAction.lastCell))) {\n        // User mouseover new cell - cell triggered.\n        userAction.lastCell = cellCoor;\n        grid.clickCell(cellCoor);\n    }\n}\nclearButton.addEventListener('click', () => { grid = new Grid(COLS, ROWS); });\ndocument.addEventListener('mousedown', (event) => {\n    userAction.isMousePressed = true;\n    cellClickHandler(event, false);\n});\ndocument.addEventListener('mouseup', () => { userAction.isMousePressed = false; });\ndocument.addEventListener('mousemove', (event) => {\n    if (userAction.isMousePressed) {\n        cellClickHandler(event, true);\n    }\n});\ntoggleButton.addEventListener('click', () => {\n    if (userAction.cellType == CellType.Obstacle) {\n        userAction.cellType = CellType.Endpoint;\n        toggleInfo.textContent = 'Endpoints';\n    }\n    else {\n        userAction.cellType = CellType.Obstacle;\n        toggleInfo.textContent = 'Obstacles';\n    }\n});\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNextCoors","currentCoor","visited","grid","diagonalFlag","neighbourCoors","cellCoor","mask","neighbours","Array","predBase","coor","isValidCellCoor","y","x","cardinalBools","fill","i","angle","Math","PI","diffVect","Vector2","cos","sin","map","component","round","cardinal","plus","push","circInc","val","bound","diagonal","diagonalIsReachable","getNeighbourCoors","typeMask","CellType","Obstacle","filter","neighbourCoor","has","coorToN","getBestUnvisitedCoor","unvisitedCoors","targetCoor","bestUnvisitedCoor","minScore","Infinity","forEach","unvisitedCoor","unvisitedCell","score","A","B","dx","abs","dy","cardinalDistance","min","coorDist","distance","canvas","document","getElementById","ctx","getContext","belowCanvas","toggleButton","toggleInfo","clearButton","diagonalCheckbox","pathInfo","layout","constructor","this","other","f","isEqual","Cell","type","parent","Grid","cols","rows","data","j","Nothing","fillStyle","fillRect","beginPath","moveTo","lineTo","stroke","set","left","top","cellColors","NToCoor","N","floor","mousePosToCellCoor","mousePos","mouse","countCell","flat","cell","length","clickCell","typeClicked","endpointCount","Endpoint","userAction","cellType","drawPath","clearPath","typeCoorArray","e","console","log","startCoor","isPathFound","endpoints","current","target","unvisited","Set","nextCoors","distanceNextPotential","nextCoor","nextCell","add","delete","from","updateGrid","pathCoor","Path","astar","checked","textContent","ar","Map","lastCell","isMousePressed","cellClickHandler","event","checkDifferent","style","addEventListener"],"sourceRoot":""}